{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      Advanced maze mapper and solver\n#\tAuthor:       James\n# \n# ------------------------------------------\n\nclass Node():\n   \"\"\"A node \n   ----------\n   Attributes:\n    \n    directions: a dictionary, values should be \"wall\"/\"unvisited\"/\"visited\"\n\n    prev_move: holds the previous move for back tracking\n\n    prev_node: holds the previous node for back tracking\n   \"\"\"\n   def __init__(self,routes,prev_move,prev_node):\n       self.directions={\"left\": routes[0],\"down\":routes[1],\"right\":routes[2],\"up\":routes[3]}\n       self.prev_move = prev_move\n       \n       self.prev_node = prev_node\n\nopposite_directions = {\"left\":\"right\",\"right\":\"left\",\"down\":\"up\",\"up\":\"down\"}\n\ndef scan():\n    \"\"\"Scans for available routes for a new node and returns the routes as an array\"\"\"\n    min_distance = 63\n    \"\"\"minimal distance for a route to be a specific route\"\"\"\n    max_distance = 1999\n    \"\"\"maximum distance for a route to be not a route \n    (this is down to the start and end of the maze being 3000, assuming this is the maximum distance of the sensor, the gird is roughly 2000, by the spec) \n    \"\"\"\n    \n    possible_routes = []\n    \"\"\"List defined for possible routes\"\"\"\n\n    # Loop to turn the robot 4 times for all the directions, checking if there is a path or a wall\n    for count in range(4):\n        drivetrain.turn_for(LEFT,90,DEGREES)\n        # if wall, add it as an \"unvisited\" path\n        if front_distance.get_distance(MM) > min_distance and front_distance.get_distance(MM) < max_distance:\n            possible_routes.append(\"unvisited\")\n        # else add it as a wall\n        else:\n            possible_routes.append(\"wall\")\n    return possible_routes\n\ndef move_robot(direction):\n    if direction == \"left\":\n        drivetrain.turn_for(LEFT,90,DEGREES)\n        drivetrain.drive_for(FORWARD,250,MM)\n        brain.print(\"LEFT\")\n        brain.new_line()\n    elif direction == \"down\":\n        drivetrain.turn_for(LEFT,180,DEGREES)\n        drivetrain.drive_for(FORWARD,250,MM)\n        brain.print(\"DOWN\")\n        brain.new_line()\n    elif direction == \"right\":\n        drivetrain.turn_for(RIGHT,90,DEGREES)\n        drivetrain.drive_for(FORWARD,250,MM)\n        brain.print(\"RIGHT\")\n        brain.new_line()\n    else:\n        drivetrain.drive_for(FORWARD,250,MM)\n        brain.print(\"FORWARD\")\n        brain.new_line()\n    drivetrain.turn_to_heading(0,DEGREES)\n\n\ndef path_decision(current_node):\n\n    directions = current_node.directions\n\n\n    if directions[\"left\"] != \"wall\" and directions[\"left\"] != \"visited\":\n        move_robot(\"left\")\n        current_node.directions[\"left\"] = \"visited\"\n        return True, \"left\",current_node\n        \n    elif directions[\"down\"] != \"wall\" and directions[\"down\"] != \"visited\":\n        move_robot(\"down\")\n        current_node.directions[\"down\"] = \"visited\"\n        return True, \"down\", current_node\n\n    elif directions[\"right\"] != \"wall\" and directions[\"right\"] != \"visited\":\n        move_robot(\"right\")\n        current_node.directions[\"right\"] = \"visited\"\n        return True,\"right\",current_node\n\n    elif directions[\"up\"] != \"wall\" and directions[\"up\"] != \"visited\":\n        move_robot(\"up\")\n        current_node.directions[\"up\"] = \"visited\"\n        return True, \"up\",current_node\n    else:\n\n        move_robot(opposite_directions[current_node.prev_move])\n        return False,opposite_directions[current_node.prev_move],current_node\n\ndef main():\n    \"\"\"Main robot thread\"\"\"\n    \n    path_stack = []\n    \"\"\"An array of all nodes currently visited, \n    using a stack data structure, because if a node has all paths as visited or walls then it needs to go back to a node that has unvisited \"\"\"\n\n    nodes = []\n    \"\"\"A list of all nodes\"\"\"\n\n    # Create a new node\n    routes = scan()\n    brain.print(\"1:\",routes[1])\n    brain.new_line()\n    brain.print(routes[0],\"   \",routes[2])\n    brain.new_line()\n    brain.print(routes[3])\n    brain.new_line()\n\n    current_node = Node(routes,\"START\",None) \n\n    count = 1\n    while True:\n        brain.print(count)\n        brain.new_line()\n\n        is_new_node, prev_move,current_node = path_decision(current_node)\n\n        brain.print(is_new_node,prev_move)\n        brain.new_line()\n        brain.print(\"       \",current_node.directions[\"up\"])\n        brain.new_line()\n        brain.print(current_node.directions[\"left\"],\"       \",current_node.directions[\"right\"])\n        brain.new_line()\n        brain.print(\"       \",current_node.directions[\"down\"])\n        brain.new_line()\n        \n        if is_new_node:\n            current_node.directions[prev_move] = \"visited\"\n            nodes.append(current_node)\n            path_stack.append(current_node)\n            \n            prev_node = current_node\n            routes = scan()\n            \n            current_node = Node(routes, prev_move, prev_node)\n\n            # Mark the opposite direction as visited to avoid revisiting it\n            current_node.directions[opposite_directions[prev_move]] = \"visited\"\n            brain.print(\"Line 172:\")\n            brain.new_line()\n            brain.print(\"       \",current_node.directions[\"up\"])\n            brain.new_line()\n            brain.print(current_node.directions[\"left\"],\"       \",current_node.directions[\"right\"])\n            brain.new_line()\n            brain.print(\"       \",current_node.directions[\"down\"])\n            brain.new_line()\n\n\n        if not is_new_node:\n            if len(path_stack) > 1:\n                path_stack.pop()\n                current_node = path_stack[-1]  \n                prev_move = current_node.prev_move  \n                move_robot(opposite_directions[prev_move])  \n                \n                brain.print(\"Backtracking to previous node...\")\n                brain.new_line()\n            else:\n                brain.print(\"No more nodes to backtrack, stopping...\")\n                brain.new_line()\n                return  \n\n# VR threads â€” Do not delete\nvr_thread(main)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}