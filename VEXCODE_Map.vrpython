{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode VR Python Project\n# \n# ------------------------------------------\n\n# Add project code in \"main\"\n\nclass Node:\n    def __init__(self,routes, prev_node, prev_move, node_num):\n        \n        # Initialise previous node and move for back tracking\n        self.node_num = node_num\n        self.prev_node = prev_node\n        self.prev_move = prev_move\n\n        # Initialise nodes possible routes\n        self.left = routes[0]\n        self.down = routes[1]\n        self.right = routes[2]\n        self.up = routes[3]\n        \n        # Initialise if visted to False for all future routes of new node\n        if self.left:\n            self.left_visted = False\n        if self.down:\n            self.down_visted = False\n        if self.right:\n            self.right_visted = False\n        if self.up:\n            self.up_visted = False\n\ndef scan():\n    max_distance = 2000\n    min_distance = 63\n    possible_routes = []\n\n    for count in range(4):\n\n        drivetrain.turn_for(LEFT,90,DEGREES)\n        if front_distance.get_distance(MM) > min_distance and front_distance.get_distance(MM) < max_distance:\n            possible_routes.append(True)\n        else:\n            possible_routes.append(False)\n    \n    return possible_routes\n\ndef create_new_node(routes,prev_node,prev_move,node_num):\n    pln(\"New Node\")\n    return Node(routes,prev_node,prev_move,node_num)\n\ndef pln(line):\n    brain.print(line)\n    brain.new_line()\n\ndef main():\n    # - Each move a node is created, \n    # - A node is added to the node stack, \n    # when moving to a new node, if the movement is the opposite of the last move, then take off the top item\n    nodes = []\n    \n    # A dict of nodes, for finding the quickest route\n    node_dict = {}\n\n    # A node counter\n    node_count = 0\n    \n    # A node tracker to track which node we are at\n    node_tracker = 0\n\n    # Start first scan\n    routes = scan()\n    # Create first node\n    current_node = create_new_node(routes,\"START\",\"START\",node_count)\n    # Add node to node stack\n    nodes.append(current_node)\n    next_move = \"\"\n\n\n    \n    while True:\n        for count in range(4):\n            if count == 1:\n                if nodes[node_tracker].left:\n                    if not nodes[node_tracker].left_visted:\n                        drivetrain.turn_for(LEFT,90,DEGREES)\n                        drivetrain.drive_for(FORWARD,250,MM)\n                        nodes[node_tracker].left_visted = True\n                        next_move = \"LEFT\"\n                        break\n                \n            elif count == 2:\n                if nodes[node_tracker].up:\n                    if not nodes[node_tracker].up_visted:\n                        drivetrain.turn_for(LEFT,180,DEGREES)\n                        drivetrain.drive_for(FORWARD,250,MM)\n                        nodes[node_tracker].up_visted = True\n                        next_move = \"DOWN\"\n                        break\n\n            elif count == 3:\n                if nodes[node_tracker].right:\n                    if not nodes[node_tracker].right_visted:\n                        drivetrain.turn_for(LEFT,270, DEGREES)\n                        drivetrain.drive_for(FORWARD,250,MM)\n                        nodes[node_tracker].right_visted = True\n                        next_move = \"RIGHT\" \n                        break\n\n            elif count == 4:\n                if nodes[node_tracker].down:\n                    if not nodes[node_tracker].down_visted:\n                        drivetrain.drive_for(FORWARD,250,MM)\n                        nodes[node_tracker].don_visted = True\n                        next_move = \"UP\"\n                        break\n        drivetrain.turn_to_heading(0,DEGREES)\n        \n        if (nodes[node_tracker].prev_move == \"LEFT\" and next_move == \"RIGHT\") or (nodes[node_tracker].prev_move == \"RIGHT\" and next_move == \"LEFT\") or  (nodes[node_tracker].prev_move == \"UP\" and next_move == \"DOWN\") or (nodes[node_tracker].prev_move == \"DOWN\" and next_move == \"UP\"):\n            node_tracker -= 1\n        else:\n            node_count += 1\n            node_tracker += 1\n            routes = scan()\n            current_node = create_new_node(routes,nodes[node_count-1],next_move,node_count)\n        \n            nodes.append(current_node)\n\n\n# VR threads â€” Do not delete\nvr_thread(main)\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}