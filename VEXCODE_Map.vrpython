{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      Advanced maze mapper and solver\n#\tAuthor:       James\n# \n# ------------------------------------------\n\n\ndef scan():\n    \"\"\"Scans for available routes for a new node and returns the routes as an array\"\"\"\n    min_distance = 63\n    \"\"\"minimal distance for a route to be a specific route\"\"\"\n    max_distance = 1999\n    \"\"\"maximum distance for a route to be not a route \n    (this is down to the start and end of the maze being 3000, assuming this is the maximum distance of the sensor, the gird is roughly 2000, by the spec) \n    \"\"\"\n    \n    possible_routes = []\n    \"\"\"List defined for possible routes\"\"\"\n\n    # Loop to turn the robot 4 times for all the directions, checking if there is a path or a wall\n    for count in range(4):\n        drivetrain.turn_for(LEFT,90,DEGREES)\n        # if wall, add it as an \"unvisited\" path\n        if front_distance.get_distance(MM) > min_distance and front_distance.get_distance(MM) < max_distance:\n            possible_routes.append(\"unvisited\")\n        # else add it as a wall\n        else:\n            possible_routes.append(\"wall\")\n    return possible_routes\n\ndef main():\n    \"\"\"Main robot thread\"\"\"\n    \n    path_stack = []\n    \"\"\"An array of all nodes currently visited, \n    using a stack data structure, because if a node has all paths as visited or walls then it needs to go back to a node that has unvisited \"\"\"\n\n    nodes = []\n    \"\"\"A list of all nodes\"\"\"\n\n    routes = scan()\n    \n\n    nodes.append(routes)\n\n    brain.print(routes)\n\n\n    if routes[0] != \"wall\":\n        drivetrain.turn_for(LEFT,90,DEGREES)\n        drivetrain.drive_for(FORWARD,250,MM)\n        moves.append(\"LEFT\")\n        queue[len(queue)-1][0] = \"visited\"\n\n    elif routes[1] != \"wall\":\n        drivetrain.turn_for(LEFT,180,DEGREES)\n        drivetrain.drive_for(FORWARD,250,MM)\n        moves.append(\"DOWN\")\n        queue[len(queue)-1][1] = \"visited\"\n\n\n\n    elif routes[2] != \"wall\":\n        drivetrain.turn_for(LEFT,270,DEGREES)\n        drivetrain.drive_for(FORWARD,250,MM)\n        moves.append(\"RIGHT\")\n        queue[len(queue)-1][2] = \"visited\"\n\n\n    else:\n        moves.append(\"UP\")\n        drivetrain.drive_for(FORWARD,250,MM)\n        queue[len(queue)-1][3] = \"visited\"\n\n\n    drivetrain.turn_to_heading(0,DEGREES)\n    \n    while True:\n        routes = scan()\n        queue.append(routes)\n\n        \n\n        brain.print(routes)\n\n\n        if routes[0] != \"wall\":\n            drivetrain.turn_for(LEFT,90,DEGREES)\n            drivetrain.drive_for(FORWARD,250,MM)\n            moves.append(\"LEFT\")\n            queue[len(queue)-1][0] = \"visited\"\n\n        elif routes[1] != \"wall\":\n            drivetrain.turn_for(LEFT,180,DEGREES)\n            drivetrain.drive_for(FORWARD,250,MM)\n            moves.append(\"DOWN\")\n            queue[len(queue)-1][1] = \"visited\"\n\n\n\n        elif routes[2] != \"wall\":\n            drivetrain.turn_for(LEFT,270,DEGREES)\n            drivetrain.drive_for(FORWARD,250,MM)\n            moves.append(\"RIGHT\")\n            queue[len(queue)-1][2] = \"visited\"\n\n\n        else:\n            moves.append(\"UP\")\n            drivetrain.drive_for(FORWARD,250,MM)\n            queue[len(queue)-1][3] = \"visited\"\n\n\n        drivetrain.turn_to_heading(0,DEGREES)\n        \n\n\n\n\n# VR threads â€” Do not delete\nvr_thread(main)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}