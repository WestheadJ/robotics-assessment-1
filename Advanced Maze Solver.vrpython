{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain = Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n\ndef main():    \n    # Stack for moves and path tracking\n    move_stack = []\n    path = [[0, 0]]  # Store (x, y) positions\n\n    # Set high speed\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n\n    x, y = 0, 0  # Track position\n\n    # While not at the end of the maze\n    while not down_eye.detect(RED):\n\n        # Start drawing\n        pen.set_pen_color_rgb(30, 144, 255, 100)\n        pen.move(DOWN)\n\n        # Try turning left first\n        drivetrain.turn_for(LEFT, 90, DEGREES)\n        move_stack.append(\"LEFT\")\n\n        # Keep turning right until an open path is found\n        while front_distance.get_distance(MM) < 65:\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n            move_stack.append(\"RIGHT\")\n\n        # Move forward\n        drivetrain.drive_for(FORWARD, 250, MM)\n        move_stack.append(\"FORWARD\")\n\n        # Update position based on heading\n        heading = drivetrain.heading(DEGREES)\n\n        if heading == 0:\n            y += 1\n        elif heading in [-90, 270]:\n            x -= 1\n        elif heading in [180, -180]:\n            y -= 1\n        elif heading in [90, -270]:\n            x += 1\n\n        path.append([x, y])\n\n    # Backtrack to start\n    step_count = len(move_stack) - 1\n    while step_count >= 0 and not down_eye.detect(GREEN):\n        step = move_stack[step_count]\n\n        if step == \"FORWARD\":\n            drivetrain.drive_for(REVERSE, 250, MM)\n        elif step == \"LEFT\":\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n        elif step == \"RIGHT\":\n            drivetrain.turn_for(LEFT, 90, DEGREES)\n\n        step_count -= 1\n\n    # Print the stack\n    brain.print(move_stack)\n    brain.new_line()\n\n    # Calculate grid boundaries\n    min_x = min(p[0] for p in path)\n    max_x = max(p[0] for p in path)\n    min_y = min(p[1] for p in path)\n    max_y = max(p[1] for p in path)\n\n    brain.print(f\"Grid size: {max_x - min_x + 1} x {max_y - min_y + 1}\")\n    brain.new_line()\n\n    # Create a blank grid filled with '1' (walls)\n    width = max_x - min_x + 1\n    height = max_y - min_y + 1\n    grid_map = [['1' for _ in range(width)] for _ in range(height)]\n\n    # Correct mapping logic\n    for x, y in path:\n        map[max_y - y][x - min_x] = '0' \n\n    # Mark start ('S') and end ('E')\n    grid_map[path[0][1] - min_y][path[0][0] - min_x] = 'S' \n    grid_map[path[-1][1] - min_y][path[-1][0] - min_x] = 'E'  \n\n    # Print the grid map\n    for i, row in enumerate(grid_map):\n        brain.print(f\"{i}: {''.join(row)}\")\n        brain.new_line()\n\n    brain.new_line()\n    brain.print(path)\n    \n\n# VR threads â€” Do not delete\nvr_thread(main)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}