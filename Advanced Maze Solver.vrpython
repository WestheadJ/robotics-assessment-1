{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain = Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n\ndef main():    \n\n    # Moves array\n    moves = []\n\n    # Coord array\n    grid_path = [[0, 0]]\n\n    # Set high speed\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n\n    # Start tracking coords\n    x, y = 0, 0 \n\n    # While not at the end of the maze\n    while not down_eye.detect(RED):\n\n        # Start drawing\n        pen.set_pen_color_rgb(30, 144, 255, 100)\n        pen.move(DOWN)\n\n        # Try turning left first\n        drivetrain.turn_for(LEFT, 90, DEGREES)\n        moves.append(\"LEFT\")\n\n        # Keep turning right until an open grid_path is found\n        while front_distance.get_distance(MM) < 65:\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n            moves.append(\"RIGHT\")\n\n        # Move forward\n        drivetrain.drive_for(FORWARD, 250, MM)\n        moves.append(\"FORWARD\")\n\n        # Update position based on heading\n        heading = drivetrain.heading(DEGREES)\n\n        if heading == 0:\n            y += 1\n        elif heading in [-90, 270]:\n            x -= 1\n        elif heading in [180, -180]:\n            y -= 1\n        elif heading in [90, -270]:\n            x += 1\n\n        grid_path.append([x, y])\n\n    # Backtrack to start\n    step_count = len(moves) - 1\n    while step_count >= 0 and not down_eye.detect(GREEN):\n        step = moves[step_count]\n\n        if step == \"FORWARD\":\n            drivetrain.drive_for(REVERSE, 250, MM)\n        elif step == \"LEFT\":\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n        elif step == \"RIGHT\":\n            drivetrain.turn_for(LEFT, 90, DEGREES)\n\n        step_count -= 1\n\n    # Calculate grid boundaries\n    min_x = min(p[0] for p in grid_path)\n    max_x = max(p[0] for p in grid_path)\n    min_y = min(p[1] for p in grid_path)\n    max_y = max(p[1] for p in grid_path)\n\n    # Create a blank grid filled with 1s for walls\n    width = max_x - min_x + 1\n    height = max_y - min_y + 1\n    grid_map = [['1' for _ in range(width)] for _ in range(height)]\n\n    # For each moved add a 0\n    for x, y in grid_path:\n        grid_map[max_y - y][x - min_x] = '0' \n\n    # Mark start start and end\n    grid_map[max_y - grid_path[0][1]][grid_path[0][0] - min_x] = 'S' \n    grid_map[max_y - grid_path[-1][1]][grid_path[-1][0] - min_x] = 'E' \n\n    # Output grid\n    for i, row in enumerate(grid_map):\n        brain.print(f\"{i}: {''.join(row)}\")\n        brain.new_line()\n\n    brain.new_line()\n    brain.print(moves)\n    \n\n# VR threads â€” Do not delete\nvr_thread(main)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}